import{_ as s,o as a,c as n,V as l}from"./chunks/framework.5ff5cf85.js";const o="/blog/assets/image.23613deb.png",u=JSON.parse('{"title":"JAVASCRIPT","description":"","frontmatter":{},"headers":[],"relativePath":"column/Interview/base_js/index.md","filePath":"column/Interview/base_js/index.md"}'),p={name:"column/Interview/base_js/index.md"},e=l(`<h1 id="javascript" tabindex="-1">JAVASCRIPT <a class="header-anchor" href="#javascript" aria-label="Permalink to &quot;JAVASCRIPT&quot;">​</a></h1><h2 id="闭包" tabindex="-1">闭包 <a class="header-anchor" href="#闭包" aria-label="Permalink to &quot;闭包&quot;">​</a></h2><p>闭包是指函数以及其在定义时可访问的外部变量的组合。简单来说，闭包是一个函数和对其周围环境（词法环境）的引用的组合体。</p><p>闭包的产生是因为 JavaScript 中的函数具有词法作用域，即函数可以访问其定义时所处的上下文中的变量。当一个函数内部定义了另一个函数，并且内部的函数引用了外部函数的变量，那么内部函数就形成了一个闭包。</p><p>闭包可以让内部函数访问到外部函数的变量，即使外部函数已经执行完毕，这也意味着闭包可以&quot;记住&quot;并访问创建它的上下文中的变量。闭包在 JavaScript 中有许多应用，包括数据封装、模块化开发、私有变量等。</p><p>理解：主要是为了设计私有的方法和变量。 优点：可以避免全局变量造成污染。 缺点：闭包会常驻内存，增加内存使用量，使用不当会造成内存泄漏。 特征：（1）函数嵌套函数。（2）在函数内部可以引用外部的参数和变量。（3）参数和变量不会以垃圾回收机制回收。</p><p>下面是一个简单的闭包示例：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">outer</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">var</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">x</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">10</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">function</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">inner</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">x</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">return</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">inner</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> closure </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">outer</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#82AAFF;">closure</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 输出 10</span></span></code></pre></div><p>闭包可以保留外部函数的变量状态，并且每次对内部函数的调用都可以访问到这些状态。这使得闭包能够在函数之间创建数据的私有空间，避免全局命名冲突，并且可以实现高级的编程模式，如柯里化和函数式编程。</p><p>注：由于闭包会持有对外部变量的引用，在使用不当的情况下可能会导致内存泄漏。因此，合理地使用闭包，避免无限制地引用外部的变量是很重要的。</p><p>此处内容由“晓”整理。</p><h2 id="防抖与节流" tabindex="-1">防抖与节流 <a class="header-anchor" href="#防抖与节流" aria-label="Permalink to &quot;防抖与节流&quot;">​</a></h2><ul><li>节流（throttle）：在规定的时间间隔范围内不会重复触发回调。只有大于这个时间间隔才会触发回调，把频繁触发变为少量触发。</li><li>防抖（debounce）：前面的所有触发都被取消，最后一次执行在规定的时间之后才会触发，也就是说如果连续快速的触发，只会执行一次。 可使用lodash插件实现函数的防抖与节流。</li></ul><h2 id="深拷贝-浅拷贝" tabindex="-1">深拷贝，浅拷贝 <a class="header-anchor" href="#深拷贝-浅拷贝" aria-label="Permalink to &quot;深拷贝，浅拷贝&quot;">​</a></h2><p>深拷贝（Deep Copy）和浅拷贝（Shallow Copy）是在编程中常用的两种拷贝数据的方式。</p><p>浅拷贝：是指创建一个新的对象或数组，并将原始对象或数组中的元素的引用复制给新对象或数组。简单来说，浅拷贝只复制对象或数组的第一层，不会递归复制嵌套的对象或数组。</p><p>深拷贝：是指创建一个新的对象或数组，并递归地复制原始对象或数组中所有的元素及其属性。也就是说，深拷贝不仅复制了第一层的对象或数组，还会递归复制嵌套的对象或数组。</p><p>为了更好地理解深拷贝和浅拷贝，以下是它们的特点和示例：</p><p>浅拷贝的特点：</p><ul><li>新对象或数组与原对象或数组共享相同的引用。</li><li>修改新对象或数组的属性或元素会影响原对象或数组。</li><li>浅拷贝可以通过一些浅拷贝方法或运算符实现，如 Object.assign()、Array.prototype.slice()、展开运算符等。</li></ul><p>示例代码：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> obj1 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">name</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Alice</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">age</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">25</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> obj2 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">assign</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">{},</span><span style="color:#A6ACCD;"> obj1)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">obj2</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">name </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Bob</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(obj1)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">// { name: &#39;Alice&#39;, age: 25 }</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(obj2)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">// { name: &#39;Bob&#39;, age: 25 }</span></span></code></pre></div><p>深拷贝的特点：</p><ul><li>新对象或数组与原对象或数组完全独立，没有共享的引用。</li><li>修改新对象或数组的属性或元素不会影响原对象或数组。</li><li>深拷贝可以通过一些深拷贝方法实现，如递归遍历拷贝、JSON 序列化与反序列化等。</li></ul><p>示例代码：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> obj1 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">name</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Alice</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">age</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">25</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> obj2 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> JSON</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">parse</span><span style="color:#A6ACCD;">(JSON</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">stringify</span><span style="color:#A6ACCD;">(obj1))</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">obj2</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">name </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Bob</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(obj1)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">// { name: &#39;Alice&#39;, age: 25 }</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(obj2)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;">  </span><span style="color:#676E95;font-style:italic;">// { name: &#39;Bob&#39;, age: 25 }</span></span></code></pre></div><p>以上内容由“晓”整理，也可学习下面这篇文章加强：<br><a href="https://juejin.cn/post/6844903929705136141" target="_blank" rel="noreferrer">如何写出一个惊艳面试官的深拷贝?(作者：ConardLi，稀土掘金)</a></p><h2 id="异步" tabindex="-1">异步 <a class="header-anchor" href="#异步" aria-label="Permalink to &quot;异步&quot;">​</a></h2><p>这部分着重要理解 Promise、async awiat、event loop 等。</p><h3 id="_1-event-loop、宏任务和微任务" tabindex="-1">1. event loop、宏任务和微任务 <a class="header-anchor" href="#_1-event-loop、宏任务和微任务" aria-label="Permalink to &quot;1. event loop、宏任务和微任务&quot;">​</a></h3><p>首先推荐一个可以在线看代码流程的网站：loupe。</p><p>然后看下这个视频学习下：到底什么是 Event Loop 呢？ 简单的例子：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">console.log(&quot;Hi&quot;);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">setTimeout(function cb() {</span></span>
<span class="line"><span style="color:#A6ACCD;">  console.log(&quot;cb&quot;); // cb 即 callback</span></span>
<span class="line"><span style="color:#A6ACCD;">}, 5000);</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">console.log(&quot;Bye&quot;);</span></span></code></pre></div><p>它的执行过程是这样的： <img src="`+o+`" alt="Alt text"></p><p>Web APIs 会创建对应的线程，比如 setTimeout 会创建定时器线程，ajax 请求会创建 http 线程。。。这是由 js 的运行环境决定的，比如浏览器。</p><p>看完上面的视频之后，至少大家画 Event Loop 的图讲解不是啥问题了，但是涉及到宏任务和微任务，我们还得拜读一下这篇文章：<a href="https://juejin.cn/post/6844903512845860872" target="_blank" rel="noreferrer">这一次，彻底弄懂 JavaScript 执行机制。</a>如果意犹未尽，不如再读下这篇非常详细带有大量动图的文章：<a href="https://juejin.cn/post/6969028296893792286#comment" target="_blank" rel="noreferrer">做一些动图，学习一下 EventLoop。</a>想了解事件循环和页面渲染之间关系的又可以再阅读这篇文章：<a href="https://juejin.cn/post/6844904165462769678" target="_blank" rel="noreferrer">深入解析你不知道的 EventLoop 和浏览器渲染、帧动画、空闲回调（动图演示）。</a></p><p><strong>注意：1.Call Stack 调用栈空闲 -&gt; 2.尝试 DOM 渲染 -&gt; 触发 Event loop。</strong></p><ul><li>每次 Call Stack 清空（即每次轮询结束），即同步任务执行完。</li><li>都是 DOM 重新渲染的机会，DOM 结构有改变则重新渲染。</li><li>然后再去触发下一次 Event loop。</li></ul><p>宏任务：setTimeout，setInterval，Ajax，DOM 事件。 微任务：Promise async/await。</p><p>两者区别：</p><p>宏任务：DOM 渲染后触发，如 setTimeout 、setInterval 、DOM 事件 、script 。 微任务：DOM 渲染前触发，如 Promise.then 、MutationObserver 、Node 环境下的 process.nextTick 。</p><p><strong>从 event loop 解释，为何微任务执行更早？</strong></p><ul><li>微任务是 ES6 语法规定的（被压入 micro task queue）。</li><li>宏任务是由浏览器规定的（通过 Web APIs 压入 Callback queue）。</li><li>宏任务执行时间一般比较长。</li><li>每一次宏任务开始之前一定是伴随着一次 event loop 结束的，而微任务是在一次 event loop 结束前执行的。</li></ul><h3 id="_2-promise" tabindex="-1">2. Promise <a class="header-anchor" href="#_2-promise" aria-label="Permalink to &quot;2. Promise&quot;">​</a></h3><p>关于这一块儿没什么好说的，最好是实现一遍 Promise A+ 规范，多少有点印象，当然面试官也不会叫你默写一个完整的出来，但是你起码要知道实现原理。</p><blockquote><p>关于 Promise 的所有使用方式，可参照这篇文章：<a href="https://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noreferrer">ECMAScript 6 入门 - Promise 对象。</a> 手写 Promise 源码的解析文章，可阅读此篇文章：<a href="https://juejin.cn/post/6945319439772434469#heading-0" target="_blank" rel="noreferrer">从一道让我失眠的 Promise 面试题开始，深入分析 Promise 实现细节。</a> 关于 Promise 的面试题，可参考这篇文章：<a href="https://juejin.cn/post/6844904077537574919" target="_blank" rel="noreferrer">要就来 45 道 Promise 面试题一次爽到底。</a></p></blockquote><p>实现一个 Promise.all：</p><div class="language-"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">Promise.all = function (promises) {</span></span>
<span class="line"><span style="color:#A6ACCD;">  return new Promise((resolve, reject) =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">    // 参数可以不是数组，但必须具有 Iterator 接口</span></span>
<span class="line"><span style="color:#A6ACCD;">    if (typeof promises[Symbol.iterator] !== &quot;function&quot;) {</span></span>
<span class="line"><span style="color:#A6ACCD;">      reject(&quot;Type error&quot;);</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">    if (promises.length === 0) {</span></span>
<span class="line"><span style="color:#A6ACCD;">      resolve([]);</span></span>
<span class="line"><span style="color:#A6ACCD;">    } else {</span></span>
<span class="line"><span style="color:#A6ACCD;">      const res = [];</span></span>
<span class="line"><span style="color:#A6ACCD;">      let count = 0;</span></span>
<span class="line"><span style="color:#A6ACCD;">      const len = promises.length;</span></span>
<span class="line"><span style="color:#A6ACCD;">      for (let i = 0; i &lt; len; i++) {</span></span>
<span class="line"><span style="color:#A6ACCD;">        //考虑到 promises[i] 可能是 thenable 对象也可能是普通值</span></span>
<span class="line"><span style="color:#A6ACCD;">        Promise.resolve(promises[i])</span></span>
<span class="line"><span style="color:#A6ACCD;">          .then((data) =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">            res[i] = data;</span></span>
<span class="line"><span style="color:#A6ACCD;">            if (++count === len) {</span></span>
<span class="line"><span style="color:#A6ACCD;">              resolve(res);</span></span>
<span class="line"><span style="color:#A6ACCD;">            }</span></span>
<span class="line"><span style="color:#A6ACCD;">          })</span></span>
<span class="line"><span style="color:#A6ACCD;">          .catch((err) =&gt; {</span></span>
<span class="line"><span style="color:#A6ACCD;">            reject(err);</span></span>
<span class="line"><span style="color:#A6ACCD;">          });</span></span>
<span class="line"><span style="color:#A6ACCD;">      }</span></span>
<span class="line"><span style="color:#A6ACCD;">    }</span></span>
<span class="line"><span style="color:#A6ACCD;">  });</span></span>
<span class="line"><span style="color:#A6ACCD;">};</span></span></code></pre></div><h3 id="_3-async-await-和-promise-的关系" tabindex="-1">3. async/await 和 Promise 的关系 <a class="header-anchor" href="#_3-async-await-和-promise-的关系" aria-label="Permalink to &quot;3. async/await 和 Promise 的关系&quot;">​</a></h3><ul><li>async/await 是消灭异步回调的终极武器。</li><li>但和 Promise 并不互斥，反而，两者相辅相成。</li><li>执行 async 函数，返回的一定是 Promise 对象。</li><li>await 相当于 Promise 的 then。</li><li>tru...catch 可捕获异常，代替了 Promise 的 catch。</li></ul><h2 id="applay-实现" tabindex="-1">applay 实现 <a class="header-anchor" href="#applay-实现" aria-label="Permalink to &quot;applay 实现&quot;">​</a></h2><p>13、原型和原型链 答： 原型：每一个 JavaScript 对象（null 除外）在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型&quot;继承&quot;属性，其实就是 prototype 对象。 原型链：由相互关联的原型组成的链状结构就是原型链。</p><h2 id="浏览器垃圾回收机制" tabindex="-1">浏览器垃圾回收机制 <a class="header-anchor" href="#浏览器垃圾回收机制" aria-label="Permalink to &quot;浏览器垃圾回收机制&quot;">​</a></h2><p>JavaScript是垃圾回收语言，哪个变量不用了就会周期性的被清除。</p><p>目前有两种策略：</p><p>标记清理和引用计数。标记清理就是在上下文执行中会标记变量的进入和离开，垃圾回收程序会做销毁带标记的变量和回收内存。引用计算就是每个值会记录引用次数，当次数为0，垃圾回收就会收走它。</p><h2 id="原型链和继承" tabindex="-1">原型链和继承 <a class="header-anchor" href="#原型链和继承" aria-label="Permalink to &quot;原型链和继承&quot;">​</a></h2><p>原型链（Prototype Chain）是 JavaScript 中对象之间继承关系的一种机制。每个对象都有一个原型对象（Prototype Object），并且可以通过原型链来访问和继承原型对象的属性和方法。</p><p>在 JavaScript 中，每个函数都有一个 <code>prototype</code> 属性，它是一个指向原型对象的指针。当我们使用 <code>new</code> 关键字创建一个对象时，这个对象会<code>继承其构造函数</code>的<strong>原型对象上</strong>的<strong>属性</strong>和<strong>方法</strong>。</p><p>原型链继承是通过将一个对象的原型设置为另一个对象实现的。在 ES6 之前，我们可以使用 <code>prototype</code> 属性和构造函数来实现继承。</p><p>下面是一个使用 <code>prototype</code> 和构造函数实现继承的示例：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 父类</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Animal</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">name</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">name</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">name</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 父类的方法</span></span>
<span class="line"><span style="color:#FFCB6B;">Animal</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">sayName</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">My name is </span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">+</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">name</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 子类</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Dog</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">name</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">breed</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">Animal</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">call</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">this,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">name</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">breed</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">breed</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 使用父类的原型对象作为子类的原型对象</span></span>
<span class="line"><span style="color:#FFCB6B;">Dog</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">create</span><span style="color:#A6ACCD;">(</span><span style="color:#FFCB6B;">Animal</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#FFCB6B;">Dog</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">constructor </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Dog</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 子类的方法</span></span>
<span class="line"><span style="color:#FFCB6B;">Dog</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">bark</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Woof!</span><span style="color:#89DDFF;">&quot;</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 创建对象并调用方法</span></span>
<span class="line"><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> dog </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Dog</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Buddy</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">Labrador</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">dog</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">sayName</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 输出 &quot;My name is Buddy&quot;</span></span>
<span class="line"><span style="color:#A6ACCD;">dog</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">bark</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 输出 &quot;Woof!&quot;</span></span></code></pre></div><p>上面了例子中：定义了一个父类 <code>Animal</code> 和一个子类 <code>Dog</code>。父类有一个 <code>name</code> 属性和一个 <code>sayName</code> 方法，子类继承了父类的属性和方法，并且添加了自己的属性 <code>breed</code> 和方法 <code>bark</code>。</p><p>使用 <code>Animal.call(this, name)</code> 来调用父类的构造函数，以便在子类中设置父类的属性。然后，通过 <code>Object.create(Animal.prototype)</code> 将父类的原型对象作为子类的原型对象，实现原型链继承。最后，我们将子类的原型对象的 <code>constructor</code> 属性设置为子类本身，这是为了保持正确的构造函数引用。</p><p>实现基于原型链的继承。子类通过原型链可以访问和继承父类的属性和方法，实现代码的复用和组织</p><h2 id="如何判断webview是否加载完成" tabindex="-1">如何判断webview是否加载完成 <a class="header-anchor" href="#如何判断webview是否加载完成" aria-label="Permalink to &quot;如何判断webview是否加载完成&quot;">​</a></h2><ol><li><a href="https://zhuanlan.zhihu.com/p/58691238" target="_blank" rel="noreferrer">你真的了解webview么？</a></li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/component/web-view.html" target="_blank" rel="noreferrer">在微信小程序的web-view，网页加载成功时候能触发bindload事件，网页加载失败的时候触发binderror事件，可根据这两个事件判断webview加载完成情况。</a></li><li><a href="https://www.jianshu.com/p/e32abad716d1" target="_blank" rel="noreferrer">通过NavigationDelegate实现判断webview加载完成情况</a></li></ol><h2 id="参考来源" tabindex="-1">参考来源 <a class="header-anchor" href="#参考来源" aria-label="Permalink to &quot;参考来源&quot;">​</a></h2><blockquote><p>来自：vortesnail ——《做了一份前端面试复习计划，保熟～》(稀土掘金)<br> 链接：<a href="https://juejin.cn/post/7061588533214969892" target="_blank" rel="noreferrer">https://juejin.cn/post/7061588533214969892</a></p></blockquote><blockquote><p>来自：MonchLee ——《可能是最好的BFC解析了...》(稀土掘金)<br> 链接：<a href="https://juejin.cn/post/6960866014384881671" target="_blank" rel="noreferrer">https://juejin.cn/post/6960866014384881671</a></p></blockquote><blockquote><p>来自：阮一峰 ——《Flex 布局教程：语法篇》 链接：<a href="https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noreferrer">https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></p></blockquote><blockquote><p>《JavaScript高级程序设计》[美]马特·弗利斯比 著 李松峰 译</p></blockquote>`,72),t=[e];function r(c,i,y,D,A,F){return a(),n("div",null,t)}const h=s(p,[["render",r]]);export{u as __pageData,h as default};
